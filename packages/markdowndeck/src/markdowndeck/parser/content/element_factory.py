import logging
from typing import Any

from markdown_it import MarkdownIt
from markdown_it.token import Token

from markdowndeck.models import (
    AlignmentType,
    CodeElement,
    ElementType,
    ImageElement,
    ListElement,
    ListItem,
    TableElement,
    TextElement,
    TextFormat,
    TextFormatType,
    VerticalAlignmentType,
)

logger = logging.getLogger(__name__)


class ElementFactory:
    """
    Factory for creating slide elements.

    This factory assumes it receives pre-cleaned text content where directives
    have already been processed by the calling formatter.
    """

    def create_title_element(
        self,
        text: str,
        directives: dict[str, Any] = None,
    ) -> TextElement:
        """Create a title element with directive support."""
        md = MarkdownIt()
        formatting = self._extract_formatting_from_inline_token(md.parse(text)[0])
        alignment = AlignmentType.CENTER
        if directives and "align" in directives:
            alignment_value = directives["align"].lower()
            if alignment_value in ["left", "center", "right", "justify"]:
                alignment = AlignmentType(alignment_value)

        return TextElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.TITLE,
            text=text,
            formatting=formatting or [],
            horizontal_alignment=alignment,
            vertical_alignment=VerticalAlignmentType.TOP,
            directives=directives or {},
        )

    def create_subtitle_element(
        self,
        text: str,
        directives: dict[str, Any] = None,
    ) -> TextElement:
        """Create a subtitle element."""
        md = MarkdownIt()
        formatting = self._extract_formatting_from_inline_token(md.parse(text)[0])
        alignment = AlignmentType.CENTER
        if directives and "align" in directives:
            alignment_value = directives["align"].lower()
            if alignment_value in ["left", "center", "right", "justify"]:
                alignment = AlignmentType(alignment_value)
        return TextElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.SUBTITLE,
            text=text,
            formatting=formatting or [],
            horizontal_alignment=alignment,
            vertical_alignment=VerticalAlignmentType.TOP,
            directives=directives or {},
        )

    def create_text_element(
        self,
        text: str,
        formatting: list[TextFormat] = None,
        alignment: AlignmentType = AlignmentType.LEFT,
        directives: dict[str, Any] = None,
        heading_level: int | None = None,
    ) -> TextElement:
        """Create a text element."""
        return TextElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.TEXT,
            text=text,
            formatting=formatting or [],
            horizontal_alignment=alignment,
            vertical_alignment=VerticalAlignmentType.TOP,
            directives=directives or {},
            heading_level=heading_level,
        )

    def create_quote_element(
        self,
        text: str,
        formatting: list[TextFormat] = None,
        alignment: AlignmentType = AlignmentType.LEFT,
        directives: dict[str, Any] = None,
    ) -> TextElement:
        """Create a quote element."""
        return TextElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.QUOTE,
            text=text,
            formatting=formatting or [],
            horizontal_alignment=alignment,
            vertical_alignment=VerticalAlignmentType.TOP,
            directives=directives or {},
        )

    def create_footer_element(
        self,
        text: str,
        directives: dict[str, Any] = None,
    ) -> TextElement:
        """Create a footer element."""
        md = MarkdownIt()
        formatting = self._extract_formatting_from_inline_token(md.parse(text)[0])
        alignment = AlignmentType.LEFT
        if directives and "align" in directives:
            alignment_value = directives["align"].lower()
            if alignment_value in ["left", "center", "right", "justify"]:
                alignment = AlignmentType(alignment_value)
        return TextElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.FOOTER,
            text=text,
            formatting=formatting or [],
            horizontal_alignment=alignment,
            vertical_alignment=VerticalAlignmentType.BOTTOM,
            directives=directives or {},
        )

    def create_list_element(
        self,
        items: list[ListItem],
        ordered: bool = False,
        directives: dict[str, Any] = None,
    ) -> ListElement:
        """Create a list element."""
        element_type = ElementType.ORDERED_LIST if ordered else ElementType.BULLET_LIST
        return ListElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=element_type,
            items=items,
            directives=directives or {},
        )

    def create_image_element(
        self, url: str, alt_text: str = "", directives: dict[str, Any] = None
    ) -> ImageElement:
        """Create an image element."""
        if not directives:
            directives = {}

        # Enforce image dimension rules from PARSER_SPEC.md with [fill] exception
        # Per Task 2 clarification: If [width] and [height] are present, they take precedence over [fill]
        has_width = "width" in directives
        has_height = "height" in directives
        has_fill = "fill" in directives

        # If both width and height are missing, check if [fill] is present
        if (not has_width or not has_height) and not has_fill:
            # Neither explicit dimensions nor [fill] - this is an error
            raise ValueError(
                f"Image '{url}' must have both [width] and [height] directives specified."
            )
            # Has [fill] but missing width/height - this is allowed per PRINCIPLES.md Section 11

        return ImageElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.IMAGE,
            url=url,
            alt_text=alt_text,
            directives=directives,
        )

    def create_table_element(
        self,
        headers: list[str],
        rows: list[list[str]],
        row_directives: list[dict[str, Any]] | None = None,
        directives: dict[str, Any] = None,
    ) -> TableElement:
        """Create a table element."""
        return TableElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.TABLE,
            headers=headers,
            rows=rows,
            row_directives=row_directives or [],
            directives=directives or {},
        )

    def create_code_element(
        self, code: str, language: str = "text", directives: dict[str, Any] = None
    ) -> CodeElement:
        """Create a code element."""
        return CodeElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.CODE,
            code=code,
            language=language,
            directives=directives or {},
        )

    def _extract_formatting_from_inline_token(self, token: Token) -> list[TextFormat]:
        """FIXED: Extract text formatting using a stateful stack-based approach."""
        if (
            token.type != "inline"
            or not hasattr(token, "children")
            or not token.children
        ):
            return []

        plain_text = ""
        formatting_data = []
        active_formats = []  # Stack to track open formats

        for child in token.children:
            child_type = getattr(child, "type", "")

            if child_type == "text":
                plain_text += child.content
            elif child_type == "code_inline":
                start_pos = len(plain_text)
                plain_text += child.content
                end_pos = len(plain_text)
                if start_pos < end_pos:
                    formatting_data.append(
                        TextFormat(
                            start=start_pos,
                            end=end_pos,
                            format_type=TextFormatType.CODE,
                        )
                    )
            elif child_type in ["softbreak", "hardbreak"]:
                plain_text += "\n"
            elif child_type.endswith("_open"):
                format_type = None
                value = True
                if child_type == "strong_open":
                    format_type = TextFormatType.BOLD
                elif child_type == "em_open":
                    format_type = TextFormatType.ITALIC
                elif child_type == "s_open":
                    format_type = TextFormatType.STRIKETHROUGH
                elif child_type == "link_open":
                    format_type = TextFormatType.LINK
                    value = (
                        dict(child.attrs).get("href", "")
                        if hasattr(child, "attrs")
                        else ""
                    )

                if format_type:
                    active_formats.append(
                        {"type": format_type, "start": len(plain_text), "value": value}
                    )

            elif child_type.endswith("_close"):
                expected_type = None
                if child_type == "strong_close":
                    expected_type = TextFormatType.BOLD
                elif child_type == "em_close":
                    expected_type = TextFormatType.ITALIC
                elif child_type == "s_close":
                    expected_type = TextFormatType.STRIKETHROUGH
                elif child_type == "link_close":
                    expected_type = TextFormatType.LINK

                # Find the corresponding opening tag on the stack
                for i in range(len(active_formats) - 1, -1, -1):
                    if active_formats[i]["type"] == expected_type:
                        fmt = active_formats.pop(i)
                        start_pos = fmt["start"]
                        end_pos = len(plain_text)
                        if start_pos < end_pos:
                            formatting_data.append(
                                TextFormat(
                                    start=start_pos,
                                    end=end_pos,
                                    format_type=fmt["type"],
                                    value=fmt["value"],
                                )
                            )
                        break

        return formatting_data
