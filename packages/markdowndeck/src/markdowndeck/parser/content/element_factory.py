import logging
from typing import Any

from markdown_it import MarkdownIt
from markdown_it.token import Token

from markdowndeck.models import (
    AlignmentType,
    CodeElement,
    ElementType,
    ImageElement,
    ListElement,
    ListItem,
    TableElement,
    TextElement,
    TextFormat,
    TextFormatType,
    VerticalAlignmentType,
)

logger = logging.getLogger(__name__)


class ElementFactory:
    """
    Factory for creating slide elements.

    This factory assumes it receives pre-cleaned text content where directives
    have already been processed by the calling formatter.
    """

    def create_title_element(
        self,
        text: str,
        directives: dict[str, Any] = None,
    ) -> TextElement:
        """Create a title element with directive support."""
        md = MarkdownIt()
        formatting = self._extract_formatting_from_inline_token(md.parse(text)[0])
        alignment = AlignmentType.CENTER
        if directives and "align" in directives:
            alignment_value = directives["align"].lower()
            if alignment_value in ["left", "center", "right", "justify"]:
                alignment = AlignmentType(alignment_value)

        return TextElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.TITLE,
            text=text,
            formatting=formatting or [],
            horizontal_alignment=alignment,
            vertical_alignment=VerticalAlignmentType.TOP,
            directives=directives or {},
        )

    def create_subtitle_element(
        self,
        text: str,
        directives: dict[str, Any] = None,
    ) -> TextElement:
        """Create a subtitle element."""
        md = MarkdownIt()
        formatting = self._extract_formatting_from_inline_token(md.parse(text)[0])
        alignment = AlignmentType.CENTER
        if directives and "align" in directives:
            alignment_value = directives["align"].lower()
            if alignment_value in ["left", "center", "right", "justify"]:
                alignment = AlignmentType(alignment_value)
        return TextElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.SUBTITLE,
            text=text,
            formatting=formatting or [],
            horizontal_alignment=alignment,
            vertical_alignment=VerticalAlignmentType.TOP,
            directives=directives or {},
        )

    def create_text_element(
        self,
        text: str,
        formatting: list[TextFormat] = None,
        alignment: AlignmentType = AlignmentType.LEFT,
        directives: dict[str, Any] = None,
        heading_level: int | None = None,
    ) -> TextElement:
        """Create a text element."""
        return TextElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.TEXT,
            text=text,
            formatting=formatting or [],
            horizontal_alignment=alignment,
            vertical_alignment=VerticalAlignmentType.TOP,
            directives=directives or {},
            heading_level=heading_level,
        )

    def create_quote_element(
        self,
        text: str,
        formatting: list[TextFormat] = None,
        alignment: AlignmentType = AlignmentType.LEFT,
        directives: dict[str, Any] = None,
    ) -> TextElement:
        """Create a quote element."""
        return TextElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.QUOTE,
            text=text,
            formatting=formatting or [],
            horizontal_alignment=alignment,
            vertical_alignment=VerticalAlignmentType.TOP,
            directives=directives or {},
        )

    def create_footer_element(
        self,
        text: str,
        directives: dict[str, Any] = None,
    ) -> TextElement:
        """Create a footer element."""
        md = MarkdownIt()
        formatting = self._extract_formatting_from_inline_token(md.parse(text)[0])
        alignment = AlignmentType.LEFT
        if directives and "align" in directives:
            alignment_value = directives["align"].lower()
            if alignment_value in ["left", "center", "right", "justify"]:
                alignment = AlignmentType(alignment_value)
        return TextElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.FOOTER,
            text=text,
            formatting=formatting or [],
            horizontal_alignment=alignment,
            vertical_alignment=VerticalAlignmentType.BOTTOM,
            directives=directives or {},
        )

    def create_list_element(
        self,
        items: list[ListItem],
        ordered: bool = False,
        directives: dict[str, Any] = None,
    ) -> ListElement:
        """Create a list element."""
        element_type = ElementType.ORDERED_LIST if ordered else ElementType.BULLET_LIST
        return ListElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=element_type,
            items=items,
            directives=directives or {},
        )

    def create_image_element(self, url: str, alt_text: str = "", directives: dict[str, Any] = None) -> ImageElement:
        """Create an image element."""
        if not directives:
            directives = {}

        # Enforce image dimension rules from PARSER_SPEC.md
        if "width" not in directives or "height" not in directives:
            raise ValueError(f"Image '{url}' must have both [width] and [height] directives specified.")

        return ImageElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.IMAGE,
            url=url,
            alt_text=alt_text,
            directives=directives,
        )

    def create_table_element(
        self,
        headers: list[str],
        rows: list[list[str]],
        row_directives: list[dict[str, Any]] | None = None,
        directives: dict[str, Any] = None,
    ) -> TableElement:
        """Create a table element."""
        return TableElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.TABLE,
            headers=headers,
            rows=rows,
            row_directives=row_directives or [],
            directives=directives or {},
        )

    def create_code_element(self, code: str, language: str = "text", directives: dict[str, Any] = None) -> CodeElement:
        """Create a code element."""
        return CodeElement(
            object_id=None,  # REFACTORED: ID is now generated by the API Generator.
            element_type=ElementType.CODE,
            code=code,
            language=language,
            directives=directives or {},
        )

    def _extract_formatting_from_inline_token(self, token: Token) -> list[TextFormat]:
        """
        Extract text formatting from an inline token's children.
        """
        if token.type != "inline" or not hasattr(token, "children") or not token.children:
            return []

        plain_text = ""
        formatting_data = []
        active_formats = []

        for child in token.children:
            child_type = getattr(child, "type", "")

            if child_type == "text":
                plain_text += child.content
            elif child_type == "code_inline":
                start_pos = len(plain_text)
                code_content = child.content
                plain_text += code_content
                if code_content.strip():
                    formatting_data.append(
                        TextFormat(
                            start=start_pos,
                            end=start_pos + len(code_content),
                            format_type=TextFormatType.CODE,
                        )
                    )
            elif child_type in ["softbreak", "hardbreak"]:
                plain_text += "\n"
            elif child_type == "image":
                alt_text = child.attrs.get("alt", "") if hasattr(child, "attrs") else ""
                plain_text += alt_text
            elif child_type.endswith("_open"):
                base_type = child_type.split("_")[0]
                format_type_enum = None
                value: Any = True
                if base_type == "strong":
                    format_type_enum = TextFormatType.BOLD
                elif base_type == "em":
                    format_type_enum = TextFormatType.ITALIC
                elif base_type == "s":
                    format_type_enum = TextFormatType.STRIKETHROUGH
                elif base_type == "link":
                    format_type_enum = TextFormatType.LINK
                    value = child.attrs.get("href", "") if hasattr(child, "attrs") else ""
                if format_type_enum:
                    active_formats.append((format_type_enum, len(plain_text), value))
            elif child_type.endswith("_close"):
                base_type = child_type.split("_")[0]
                expected_format_type = None
                if base_type == "strong":
                    expected_format_type = TextFormatType.BOLD
                elif base_type == "em":
                    expected_format_type = TextFormatType.ITALIC
                elif base_type == "s":
                    expected_format_type = TextFormatType.STRIKETHROUGH
                elif base_type == "link":
                    expected_format_type = TextFormatType.LINK
                for i in range(len(active_formats) - 1, -1, -1):
                    fmt_type, start_pos, fmt_value = active_formats[i]
                    if fmt_type == expected_format_type:
                        if start_pos < len(plain_text):
                            formatting_data.append(
                                TextFormat(
                                    start=start_pos,
                                    end=len(plain_text),
                                    format_type=fmt_type,
                                    value=fmt_value,
                                )
                            )
                        active_formats.pop(i)
                        break
        return formatting_data
